ORG	0x0		; Инициализация векторов прерывания
V0:	WORD $DEFAULT, 0x180	; Вектор прерывания #0 
V1:	WORD $INT1, 0x180	; Вектор прерывания #1
V2:	WORD $DEFAULT, 0x180 	; Вектор прерывания #2
V3:	WORD $DEFAULT, 0x180	; Вектор прерывания #3
V4:	WORD $DEFAULT, 0x180	; Вектор прерывания #4
V5:	WORD $DEFAULT, 0x180	; Вектор прерывания #5
V6:	WORD $DEFAULT, 0x180	; Вектор прерывания #6
V7:	WORD $DEFAULT, 0x180	; Вектор прерывания #7

DEFAULT:	IRET	; Просто возврат
ORG	0x20   	; Загрузка начальных векторов прерывания
START:	DI	; Запрет прерывания
	CLA	; Очистка AC
	LD #9	; Разрешить прерывания и вектор №1
	OUT 0x19	; Разрешение прерывания для ВУ-8 (клавиатура)
	EI	; Разрешить прерывание

INT1:	
	SAVE:	WORD ?	; Переменная для сохранения оставшейся части после сдвига
	INDEX:	WORD ?	; Переменная для сохранения увеличенного индекса

	READ:	DI	; Запрет прерываний
		CLA	; Очистка аккумулятора
		LD #0x00	; Инициализация переменной INDEX
		ST $INDEX	; Инициализация переменной INDEX
		CLA	; Очистка аккумулятора
		IN 0x019	; Считываем информацию из State Register клавиатуры
		AND #0x40	; Проверка на готовность ввода клавиатуры через SR (клавиша нажата?)
		BEQ READ	; Если не нажата -> функция READ заново
		IN 0x018	; Считываем информацию из Data Register клавиатуры
		CMP #0x0A	; Проверяем на стоп-слово (клавиша ENTER)
		BEQ EXIT	; Если стоп-слово -> функция EXIT
		ST $SAVE	; Сохранение кода введенного символа в переменную SAVE

	WRITE:	CLA	; Очистка аккумулятора
		LD $SAVE	; Загрузка переменной SAVE
		BEQ READ	; Если равна нулю (Z==1) -> READ
		ASR	; Арифметический сдвиг переменной SAVE
		ST $SAVE	; Сохранение оставшейся части после сдвига
		BHIS DO	; Если до сдвига последний бит был равен 1 -> функция DO
		BLO NO	; Если до сдвига последний бит был равен 0 -> функция NO
		JUMP WRITE	; Переход в начало функции WRITE

	DO:	DI	; Запрет прерываний
		CLA	; Очистка аккумулятора
		IN 0x15	; Считываем информацию из State Register семисегментного индикатора
		AND #0x40	; Проверка на готовность вывода на семисегментный индикатор через SR (включен?)
		BEQ DO	; Если не нажата -> функция DO заново
		LD $INDEX	; Загрузка индекса (в первый раз равен 0x00)
		INC	; Инкремент (в первый раз 0x01) - для вывода 1 в ячейку ВУ-7
		OUT 0x14	; Вывод содержимого аккумулятора на семисегментный индикатор
		DEC	; Декремент (в первый раз 0x00) - возврат в исх. состояние
		ADD #0x10	; Увеличиваем индекс для выбора слледующей ячейки
		ST $INDEX	; Сохраняем индекс
		JUMP WRITE	; Возврат -> функция WRITE

	NO:	DI	; Запрет прерываний
		CLA	; Очистка аккум
		IN 0x15	; Считываем информацию из State Register семисегментного индикатора
		AND #0x40	; Проверка на готовность вывода на семисегментный индикатор через SR (включен?)
		BEQ NO	; Если не нажата -> функция NO заново
		LD $INDEX	; Загрузка индекса (в первый раз равен 0x00)
		OUT 0x14	; Вывод содержимого аккумулятора на семисегментный индикатор
		ADD #0x10	; Увеличиваем индекс для выбора слледующей ячейки
		ST $INDEX	; Сохраняем индекс
		JUMP WRITE	; Возврат -> функция WRITE

EXIT:	HLT		; функция остановки программы